<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event Loop Use Case Experiments</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
  {{{feLibs 'library' 'modules' 'event-loop-use-case-experiments' 'event-loop-use-case-cpu-hungry-task' 'js'}}}
</head>

<body class='container'>
  <header class='row'>
    <h1>Event Loop Use Case - CPU Hungry Task</h1>
  </header>

  <main class="row">
    <section>
      <h2>Splitting CPU-hungry tasks</h2>
      <p>When a script is running, the browser can't do anything else. In particular, it can't react to user actions
        (clicks, selections, etc.).</p>

      <p>Example of unoptimized script:</p>
      <pre>
let i = 0;
let start = Date.now();
function count() {
  // do a heavy job
  for (let j = 0; j < 1e9; j++) {
    i++;
  }
  alert("Done in " + (Date.now() - start) + 'ms');
}
count();
    </pre>
      <article>
        <p>
          The browser may even show a “the script takes too long” warning, and suggest to stop it.
        </p>
      </article>
      <button class="btn btn-danger" id='js-un-optimized-splitting-cpu-hungry-task'>Run</button>

    </section>

    <section>
      <h2>Use setTimeout to split the job</h2>
      <p>Example:</p>

      <pre>
let i = 0;
let start = Date.now();
function count() {
  // do a piece of the heavy job (*)
  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  } else {
    setTimeout(count); // schedule the new call (**)
  }
}
count();
      </pre>
      <article>
        <p>Now the browser interface is fully functional during the “counting” process.</p>
        <p>A single run of count does a part of the job (*), and then re-schedules itself (**) if needed:</p>
        <ul>
          <li>First run counts: <code>i=1...1000000</code>.</li>
          <li>Second run counts: <code>i=1000001..2000000</code>.</li>
          <li>…and so on.</li>
        </ul>
        <p>Now, if a new side task (e.g. onclick event) appears while the engine is busy executing part 1, it gets
          queued and then executes when part 1 finished, before the next part. Periodic returns to the event loop
          between count executions provide just enough “air” for the JavaScript engine to do something else, to react to
          other user actions.</p>
      </article>
      <button class="btn btn-warning" id='js-set-timeout-splitting-cpu-hungry-task'>Run</button>

    </section>

    <section>
      <h2>Improved setTimeout Implementation</h2>
      <p>We’ll move the scheduling to the beginning of the <code>count()</code>:</p>
      <pre>
let i = 0;
let start = Date.now();
function count() {
  // move the scheduling to the beginning
  if (i < 1e9 - 1e6) {
    setTimeout(count); // schedule the new call
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  }
}
count();
      </pre>
      <article>
        <p>Now when we start to <code>count()</code> and see that we’ll need to <code>count()</code> more, we schedule
          that immediately, before doing the job.</p>
        <p>If you run it, it’s easy to notice that it takes significantly less time.</p>
        <p>Why?</p>
        <p>That’s simple: as you remember, there’s the in-browser minimal delay of 4ms for many nested setTimeout calls.
          Even if we set 0, it’s 4ms (or a bit more). So the earlier we schedule it – the faster it runs.</p>
        <p>Finally, we’ve split a CPU-hungry task into parts – now it doesn’t block the user interface. And its overall
          execution time isn’t much longer.</p>
      </article>
            <button class="btn btn-primary" id='js-improved-set-timeout-splitting-cpu-hungry-task'>Run</button>
    </section>

  </main>

  <footer>

  </footer>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous" async
    defer></script>
</body>

</html>